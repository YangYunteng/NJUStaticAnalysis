# 软件分析笔记

## Chapter 1 Introduction

### PL

PL: programming Languages(程序设计语言)可以分为以下三个部分：

1. Theory
   1. Language design;
   2. Type design;
   3. Semantics and logics
   4. ...
2. Environment 
   1. Compilers
   2. Runtime System
   3. .....
3. Application
   1. Programming Analysis
   2. Programming vertification
   3. Programming synthesis

三类编程语言：命令式、函数式、逻辑式编程语言

### Static Analysis 作用

- Program Reliability (程序可靠性)
  - Null Pointer dereference, memory leak,etc.
- Program Security (程序安全性)
  - Private information leak, injection attack, etc.
- Compiler Optimization (编译优化)
  - Dead code elimination, code motion(代码调整), etc.
- Program Understanding
  - IDE call hierarchy, type information, etc.

3. Static Analysis

   完美的静态分析是不存在的。

   Sound/Truth/Complete:

   Truth:代表程序中的事实，例如：程序中有10个内存泄漏

   Sound(Overapproximate):会产生误报的情况（可能误报为12个）

   Complete(精度，Underapproximate):会产生漏报的情况（可能只报了5个bug,还有5个没有分析出来）

所以不存在完美静态分析，只需要静态分析有意义即可（Useful static analysis）,所以一般会有两种方式来解决：

1. compromise soundness:就是会产生漏报(false negative)
2. compromise complete:就是会产生误报（false positive）

绝大多数都是compromise completeness: Sound and not fully-precise static analysis。（宁可误报，但一定要全面）

### 两个词概括静态分析

抽象（Abstraction）、近似（Over-approximation）

抽象：阈值转化

近似：转换函数（transfer function）、Control flow(控制流)



## Chapter 2 Intermediate Representation

### Compiler

Source Code 进过以下步骤变为机器码

1. Scanner (Lexical Analysis  词法分析（检查字符以及单词是否合理）需要一定的词典（Regular Expression）)

   生成Tokens

2. Parser (Syntax Analysis  语法分析  Context-Free Grammer 上下文无关文法)

   生成AST

3. Type Checker(Semantic Analysis 语义分析 Attribute Grammer(当然编译器只能做简单的语义分析，比如浮点数转整数))

   生成Decorated AST

4. Translator

   生成IR(静态分析使用的便是IR)

5. Code Generator

   生成Machine Code

### AST vs. IR

AST 会更加贴合程序语言（可以参考编译过程）

1. high-level and closed to grammer structure
2. usually language dependent
3. suitable for fast type checking;
4. lack of control flow information

IR 会更加贴近汇编语言 (language independent, compact and uniform)

1. low-level and closed to machine code
2. usually language independent
3. compact and uniform
4. contains control flow information
5. usually considered as the basis for static analysis

### 3-Address Code

三地址码（3AC）在指令的右边最多只有一个操作符

Address可以包含以下三种

1. Name(变量名)
2. Constant(常量名)
3. Compiler-generated temporary(编译器生成的临时变量)

### Soot 中语法介绍

JVM 四种类型函数调用

1. invokespecial: call constructor, call superclass methods, call private methods
2. invokevirtual: instance methods call (virtual dispatch 派生)
3. invokeinterface(类似invokevirtual): cannot optimization, checking interface implementation
4. invokestatic: call static methods

Java 7之后: invokedynamic -> Java static typing, dynamic language runs on JVM

method signature: class name; return type(返回值); method name(parameter1 type,parameter2 type,...)



clinit 在Java中进行静态属性的初始化

### Static Single Assignment(SSA)

每个变量只会进行一次定义

对于分支中SSA的使用，会通过merge function函数进行变量合并

SSA优点

1. 流信息可以间接融入到每个单独的变量名
2. Define-and-Use pairs are explicit

SSA缺点

1. SSA会导致太多变量名
2. 在转换为机器码之后会导致出现低效问题

### Control Flow Analysis

IR(3AC)最终还是需要转换为CFG(Control Flow Graph)进行分析

CFG serves as the basic structure of static analysis

#### Node: Basic Blocks

Basic Blocks 可以认为是CFG的节点	

Basic Blocks(BB) are maximal sequences of consecutive three-address instructions（最大连续三地址码指令） with the properties that:

1. 此段程序的入口只能在最开始
2. 此段程序只能在最后退出

ps:如果goto label1,一般goto这一行会作为BB的结尾，而label1则只能作为BB的开始

一段三地址码P的BB划分的算法

1. The first instruction in P is a leader
2. Any target instruction of a conditional or unconditional jump is a leader（满足性质1）
3. Any instruction that immediately follows a conditonal or unconditional jump is a leader（满足性质2）

A BB consists of a leader and all its subsequent instructions until the next leader

#### Edge

如果block A和block B 之间存在的一条边，当且仅当

1. A和B 之间存在有条件或无条件跳转
2. B直接跟着A 并且A的最后一条指令不是无条件跳转

称A是B 的前驱（predecessor）;B是A 的后继（successor）

#### Entry 以及 Exit

在CFG会自动需要加入Entry和Exit节点



## Chapter 3 Static Program Analysis

### Data Flow Analysis - Applications

1. Overview of Data Flow Analysis
2. Preliminaries of Data Flow Analysis 
3. Reaching Definitions Analysis 
4. Live Variables Analysis
5. Available Expressions Analysis

#### may analysis vs. must analysis

may analysis: outputs information that may be true(over-approximation sound)

must analysis: outputs information that must be true(under-approximation complete)

#### Input and Ouput States

见PPT

#### Reaching Definitions Analysis

over-approximation;may analysis

为什么算法会停止？

OUTPUT never shrinks,并且IN会有增长极限（可以见PPT）

为什么可以通过OUTPUT没有变化作为算法结束的判断条件？

主要是可以通过算法公式，可以看出OUT取决于IN(此处存在不动点概念，之后会进行介绍)

#### Live Variables Analysis

活跃变量分析

forward 以及 backward都是可以进行活跃变量分析，但是backward会更加直观

#### Available Expressions Analysis

must analysis; merge function 使用交集

### Data Flow Analysis - Foundations